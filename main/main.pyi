import pygame
from typing import Union, Callable, Dict, Tuple, Any, Optional, Sequence, Type


AnyVector = Union[Tuple[float, float], pygame.math.Vector2, Vector2]
EventDictType = Dict[int, Callable[[], None]]
Color = pygame.Color
Event = pygame.event.Event
Surface = pygame.surface.SurfaceType


class Vector2(pygame.math.Vector2):
    def get_intiger_xy(self) -> Tuple[get_intiger_xy, get_intiger_xy]: ...
    def get_xy(self) -> Tuple[float, float]: ...

class Game(object):
    def __init__(self, screenSize: tuple[int, int]) -> None:
        self.display: pygame.Surface = None
        self.clock: pygame.time.Clock = None
        self.is_running: bool = None
        self.tick_callabe: Callable[[int], None] = None
        self.draw_callable: Callable[[], None] = None
        self.event_callable: Callable[[Event], None] = None
        ...
    def run(self) -> None: ...
    def tick(self) -> None: ...
    def draw(self) -> None: ...
    def handle_events(self) -> None: ...
    def exit(self) -> None: ...
    @staticmethod
    def set_caption(caption: str) -> None: ...
    def quick_render(self, list_of_drawables: Sequence[Type[Drawable]]) -> None: ...


class Drawable:
    def __init__(self, display:pygame.Surface, pos:AnyVector,
                 hitbox: Optional[pygame.Surface] = None) -> None:
        self.display: pygame.Surface = None
        self.position: Vector2 = None
        self.hitbox: Optional[pygame.Surface] = None
        ...
    def tick(self, dt:int) -> None: ...
    def draw(self) -> pygame.Surface: ...
    def move_to(self, pos:AnyVector) -> None: ...
    def move_by(self, offset:AnyVector) -> None: ...
    def is_clicked(self, clickPos: AnyVector) -> bool: ...
    def draw_offset(self) -> Vector2: ...

class Image(Drawable):
    def __init__(self, display: pygame.Surface, pos:AnyVector, image:pygame.Surface) -> None:
        self.image: pygame.Surface = None
        ...
    def draw(self) -> pygame.Surface: ...
